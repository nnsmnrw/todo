
## 最小前缀和（sum.cpp）—CF1779C—1600
时间限制 $ 1s$   |   空间限制 $ 256M$

#### 题目描述：

定义长度为 $n$ 的数组 $a_i$ 的前缀和数组为 $s_i$，对于一次操作，你可以选择一个数，变为这个数的相反数，给定一个数 $m$，请你求出最小的操作次数使序列满足：$\forall i\in[1,n], s_i\geq s_m$。

#### 输入格式：

第一行输入整数 $ t $ ( $ 1 \leq t \leq 10\,000 $ )，表示样例组数；
每组样例第一行输入两个整数 $ n $ 和 $ m $ ( $ 1 \leq m \leq n \leq 2\cdot 10^5 $ ) ，表示数组大小和最小前缀和的下标；
第二行输入 $ n $ 个整数 $ a_1,a_2, \ldots, a_n $ ( $ -10^9 \leq a_i \leq 10^9 $ ) 表示原数组；
保证一组样例中所有 $ n $ 的和不超过 $ 2\cdot 10^5 $ .

#### 输出格式：

对于每组样例，输出最小操作次数。

#### 样例输入输出：

| 样例1输入                                                    | 样例1输出                       |
| ------------------------------------------------------------ | ------------------------------- |
| 6<br/>4 3<br/>-1 -2 -3 -4<br/>4 3<br/>1 2 3 4<br/>1 1<br/>1<br/>5 5<br/>-2 3 -5 1 -20<br/>5 2<br/>-2 3 -5 -5 -20<br/>10 4<br/>345875723 -48 384678321 -375635768 -35867853 -35863586 -358683842 -81725678 38576 -357865873 | 1<br/>1<br/>0<br/>0<br/>3<br/>4 |

<div STYLE="page-break-after: always;"/>

#### 题解：前缀和、优先队列

​	$s_i\geq s_m$ 那么 $s_i-s_m>0(i>m)$ 或  $s_m-s_i<0(i<m)$ ，以 $i>m$ 为例， $s_i-s_m>0$ 说明 $m+1$ 到 $i$ 的区间和应该大于  $0$，我们从 $m+1$ 开始累加，如果某个位置的累加和小于等于 $0$ 那么我们应该将一个负数（一定存在）修改为正数，所有数的修改代价都相同，我们必然会选择这段区间中绝对值最大的负数，用优先队列维护即可。 $i<m$ 的思路同上。

#### 参考代码：

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a[200005];
int t,n,m,i,k,s;
signed main()
{
	scanf("%lld",&t);
	while(t--)
	{
		scanf("%lld%lld",&n,&m);k=s=0;
		priority_queue<int> q1;//大根优先队列
		priority_queue<int,vector<int>,greater<int> > q2;//小根优先队列
		for(i=1;i<=n;i++) scanf("%lld",&a[i]);
		if(n==1) puts("0");continue;
		for(i=m;i>1;i--)//不能为0
		{
			k+=a[i];
			q1.push(a[i]);
			if(k>0)//需要修改
			{
				k-=q1.top()*2ll;//最大值 x 取反后对 k 的贡献减小 2*x
				q1.pop();s++;
			}
		}
		k=0;
		for(i=m+1;i<=n;i++)
		{
			k+=a[i];
			q2.push(a[i]);
			if(k<0)//需要修改
			{
				k-=q2.top()*2ll;
				q2.pop();s++;
			}
		}
		printf("%lld\n",s);
	}
	return 0;
}
```
